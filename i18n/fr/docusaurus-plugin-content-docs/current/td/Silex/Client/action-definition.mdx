---
id: action-definition
title: DÃ©finir les action
sidebar_position: 30
---

import { PROD_ROOT } from "@site/src/constants";

Les actions sont dÃ©finies avec les fichiers YAML

## OÃ¹ dois-je placer mon yaml ?

Silex cherchera des dÃ©finitions d'action Ã  l'aide de la variable d'environment `SILEX_ACTION_CONFIG`.
Le yaml doit Ãªtre dans une catÃ©gorie. La catÃ©gorie par dÃ©faut est la catÃ©gorie `actions`. Lorsque vous appelez une action, si vous ne spÃ©cifiez pas une catÃ©gorie, silex cherchera le yaml dans le dossier actions

```
ğŸ“¦config
 â”— ğŸ“‚actions
   â”— ğŸ“œyour_action.yml
   ğŸ“‚action_category
   â”— ğŸ“œyour_action.yml
```

## SchÃ©ma de dÃ©finitions d'action

L'action est organisÃ©e en hiÃ©rarchie. Uneaction est composÃ©e d'Ã©tapes, une Ã©tape est composÃ©e de commandes et une commande est composÃ©e de paramÃ¨tres.

-  L'`action` contient des `Ã©tapes`, c'est l'entitÃ© de niveau supÃ©rieur avec quelques informations globales
- Les `Ã©tapes` sont ici pour grouper les `commandes`. Ils ne dÃ©tiennent pas beaucoup de donnÃ©es, ils ont un index attributs qui est trÃ¨s important. L'ordre d'exÃ©cution dÃ©pend de cet index, l'utilisation d'une structure de donnÃ©es clÃ©/valeur au lieu d'un simple tableau permet d'insÃ©rer facilement des Ã©tapes entre les autres. Lorsqu'une action hÃ©rite d'une autre, elle peut insÃ©rer une Ã©tape en la dÃ©finissant avec un index qui se trouve entre deux autres Ã©tapes. C'est pourquoi nous augmentons habituellement les Ã©tapes de 10 ou 100 pour permettre des insertions potentielles plus tard
- La `commande` est liÃ©e Ã  un morceau de code Ã  exÃ©cuter, elle contient des `paramÃ¨tres` et est responsable d'appeler le code en fournissant la valeur de ses `paramÃ¨tres`. Il contient Ã©galement la sortie de l'exÃ©cution
- Le `paramÃ¨tre` peut soit stocker une valeur brute ou Ãªtre connectÃ© Ã  une sortie de `commande`. Il a un type et assure-vous que le type fourni est correct. Atention, pour les types invalides, silex va essayer de lancer la valeur, il est utile dans la plupart des cas, mais parfois il peut se traduire par des rÃ©sultats Ã©tranges.

:::tip
Vous devez Ãªtre prudant avec YAML, Une indentation peut rendre votre action entiÃ¨re fausse. Et l'erreur est trÃ¨s cryptique
:::

Voici Ã  quoi devrait ressembler une dÃ©finition d'action :

```yml
<action_name>:
  # Lâ€™Ã©tiquette est juste pour lâ€™affichage, vous pouvez lâ€™omettre, dans ce cas le nom sera utilisÃ© (la clÃ© qui est dans l'action)
  label: "<string> (default: value in the key)"
  # SpÃ©cifiez si cette action doit Ãªtre affichÃ©e sur lâ€™interface utilisateur, certaines actions nâ€™ont pas besoin dâ€™une interface avec une fenÃªtre contextuelle
  hide: "<boolean> (default: false)"
  # Un peu dâ€™aide qui sera affichÃ©e sur lâ€™interface utilisateur
  tooltip: "<string> || null (default: null)"

  steps:
    <step_name>:
      # Lâ€™Ã©tiquette est juste pour lâ€™affichage, vous pouvez lâ€™omettre, dans ce cas le nom sera utilisÃ© (la clÃ© qui est dans l'Ã©tape)
      label: "<string> (default: value in the key)"
      # PrÃ©ciser si cette Ã©tape doit Ãªtre affichÃ©e sur lâ€™interface utilisateur
      hide: "<boolean> (default: false)"
      # Un peu dâ€™aide qui sera affichÃ©e sur lâ€™interface utilisateur
      tooltip: "<string> || null (default: null)"
      # Lâ€™index est utilisÃ© pour dÃ©finir lâ€™ordre dâ€™exÃ©cution, on incrÃ©mente habituellement 10 par 10 pour pouvoir insÃ©rer des Ã©tapes plus tard si une autre action hÃ©rite de celle-ci
      index: "<int> (default: 0)"

      commands:
        <command_name>:
          # Le libellÃ© est juste pour lâ€™affichage, vous pouvez lâ€™omettre, dans ce cas le nom sera utilisÃ© (la clÃ© qui est dans cette commande)
          label: "<string> (default: value in the key)"
          # SpÃ©cifier si cette commande doit Ãªtre affichÃ©e sur lâ€™interface utilisateur
          hide: "<boolean> (default: false)"
          # Un peu dâ€™aide qui sera affichÃ©e sur lâ€™interface utilisateur
          tooltip: "<string> || null (default: null)"
          # Le chemin qui mÃ¨ne Ã  la commande python Ã  exÃ©cuter, le format est comme une important python rÃ©guliÃ¨re (ex: 'silex_plugin.commands.my_command.MyCommand'). Voir la page de dÃ©finition de commande pour plus d'informations)
          path: "<string> (default: '')"
          # PrÃ©ciser si lâ€™exÃ©cution doit sâ€™arrÃªter avant cette commande, et demander Ã  lâ€™utilisateur de modifier les paramÃ¨tres
          ask_user: "<boolean> (default: false)"

          parameters:
            <parameter_name>:
              # Lâ€™Ã©tiquette est juste pour lâ€™affichage, vous pouvez lâ€™omettre, dans ce cas le nom sera utilisÃ© (la clÃ© qui est dans ce paramÃ¨tre)
              label: "<string> (default: value in the key)"
              # PrÃ©ciser si ce paramÃ¨tre doit Ãªtre affichÃ© sur lâ€™interface utilisateur
              hide: "<boolean> (default: false)"
              # Un peu dâ€™aide qui sera affichÃ©e sur lâ€™interface utilisateur
              tooltip: "<string> || null (default: null)"
              # La valeur par dÃ©faut de ce paramÃ¨tre
              value: "<any> (default: null)"
```

## Connexions

Vous pouvez connecter la sortie d'une commande Ã  l'entrÃ©e d'un paramÃ¨tre. Pour ce faire, utilisez le tag `!command-output` avec un string spÃ©cifiant le chemin de la commande (ex: `value: !command-output "<step_name>:<command_name>"`)
Si la commande retourne un dictionnaire, vous pouvez obtenir une valeur spÃ©cifique de ce dictionnaire en ajoutant plus de clÃ©s au chemin.

Par exemple, si la commande retourne `{"foo": {"bar": "baz"}}` vous pouvez accÃ©der au string `baz` en dÃ©finissant le chemin sur `"<step_name>:<command_name>:foo:bar"`.

:::info
Nous utilisons les dictionnaires comme moyen pour les commandes d'avoir plusieurs sorties, c'est pourquoi il est toujours bon de sortir un dictionnaire dans les commandes mÃªme s'il n'y a qu'une sortie, juste au cas oÃ¹ nous le mettions Ã  jour plus tard avec plus de sorties.
:::

## HÃ©ritage

Certaines actions sont trÃ¨s similaire, pour Ã©viter d'avoir Ã  refaire les mÃªme choses encore et encore, vous pouvez utiliser l'hÃ©ritage. Pour utiliser l'hÃ©ritage, vous devez d'abord comprendre comment silex rÃ©sout une action Ã  partir de son nom. Il utilise la variable d'environment `SILEX_ACTION_CONFIG`, qui consiste en une liste de chemin, il suffit de lister la variable `PATH`.

Par exemple:

- <span>\\{PROD_ROOT}\rez\packages\test_pipe</span>
- <span>\\{PROD_ROOT}\rez\packages\silex_maya</span>
- <span>\\{PROD_ROOT}\rez\packages\silex_client</span>

Ici, le [contexte](./context.md) a silex_client chargÃ© et 2 plugins, silex_maya et test_pipe. L'ordre dans lequel les plugins sont chargÃ©s importe beaucoup. Lorsque silex cherche une action, il regarde de haut en bas de la liste. Vous devez le savoir si vous utilisez l'hÃ©ritage parce qu'une action ne peut **hÃ©riter que d'une autre action qui est dans le niveau actuel ou infÃ©rieur**.

La syntaxe pour l'hÃ©ritage est :

```yml
my_action: !inherit
  # Le nom de l'action dont vous voulez hÃ©riter. Vous pouvez ajouter un '.' devant le nom si vous voulez que silex commence Ã  chercher des actions au niveau actuel
  # Si vous ne mettez pas un . silex commencera Ã  chercher l'action en commenÃ§ant au niveau sous le niveau actuel.
  parent: "<string> (default: null)"
  # Si vous souhaitez hÃ©riter dâ€™une partie spÃ©cifique de lâ€™action, utilisez la clÃ© pour la spÃ©cifier
  key: "<string> (default: <same value as the parent>)"
  # Le nom de la catÃ©gorie de lâ€™action dont vous souhaitez hÃ©riter
  category: "<string> (default: <same value as the current category>)"
```

Vous n'avez pas Ã  hÃ©riter d'une action entiÃ¨re, une partie de votre action peut hÃ©riter d'une partie d'une autre action.
Dans l'exemple ci-dessous, le tag `!inherit` est utilisÃ©e Ã  la racine de l'action. Mais vous pouvez aussi l'utiliser Ã  la clÃ© d'une Ã©tape ou d'une commande.
Si vous le faites, vous devez utiliser l'option `key` et l'utiliser pour spÃ©cifier quelle partie de l'action vous voulez insÃ©rer (exemple: `action_name.step_name` si vous voulez une Ã©tape qui hÃ©rite d'une Ã©tape spÃ©cifique)

:::info
Le cas d'utilisateur pour l'hÃ©ritage est gÃ©nÃ©ralement de rÃ©duire la rÃ©pÃ©tition ou de personnaliser le comportement d'une action pour un [contexte](./context.md) spÃ©cifique. Par exemple, vous pouvez crÃ©er un plugin pour un projet et personnaliser le comportement de cette action pour les contextes qui incluent spÃ©cifiquement ce projet.
:::

Pour override une valeur, ajoutez seulement les keys pour la valeur que vous voulez override. Par exemple, nous avons ici une action vrscene (un publish vrscene)
qui est personnalisÃ©e pour un certain projet, nous dÃ©finissions le paramÃ¨tre merge Ã  true (ui est un paramÃ¨tre cachÃ©) uniquement pour les contextes oÃ¹ ce plugin est chargÃ©.

```yml
vrscene: !inherit
  parent: "vrscene"

  steps:
    move:
      commands:
        move:
          parameters:
            merge: true
```

## Ordre d'override de valeur

Du point oÃ¹ l'action est dÃ©finie au point oÃ¹ elle est exÃ©cutÃ©e, la valeur de certains champs peut changer de multiples faÃ§ons. Voici l'ordre dans lequel une valeur de paramÃ¨tre sera dÃ©finie :

1. La valeur par dÃ©faut du paramÃ¨tre est dÃ©finie dans la dÃ©finition de la commande
2. Il peut alors overriden dans la dÃ©finition YAML de l'action qui uilise cette commande
3. Lorsque l'action est crÃ©Ã©e, la valeur peut alors Ãªtre modifiÃ©e avec l'argument `set_parameter` ou `--parameter`
4. Lorsque l'action est exÃ©cutÃ©e, si la commande est dÃ©finie sur `ask_user: true`, l'utilisateur mettra Ã  jour la valeur avant l'exÃ©cution
5. Juste aprÃ¨s que l'utilisateur change la valeur, la mÃ©thode `setup` est appelÃ©e qui pourrait dÃ©finir une derniÃ¨re fois la valeur. (voir la page de dÃ©finition de la commande)
