---
id: action-definition
title: DÃ©finir les action
sidebar_position: 30
---

import { PROD_ROOT } from "@site/src/constants";

Les actions sont dÃ©finies avec les fichiers YAML

## OÃ¹ dois-je placer mon yaml ?

Silex cherchera des dÃ©finitions d'action Ã  l'aide de la variable d'environment `SILEX_ACTION_CONFIG`.
Le yaml doit Ãªtre dans une catÃ©gorie. La catÃ©gorie par dÃ©faut est la catÃ©gorie `actions`. Lorsque vous appelez une action, si vous ne spÃ©cifiez pas une catÃ©gorie, silex cherchera le yaml dans le dossier actions

```
ğŸ“¦config
 â”— ğŸ“‚actions
   â”— ğŸ“œyour_action.yml
   ğŸ“‚action_category
   â”— ğŸ“œyour_action.yml
```

## SchÃ©ma de dÃ©finitions d'action

L'action est organisÃ©e en hiÃ©rarchie. Uneaction est composÃ©e d'Ã©tapes, une Ã©tape est composÃ©e de commandes et une commande est composÃ©e de paramÃ¨tres.

-  L'`action` contient des `Ã©tapes`, c'est l'entitÃ© de niveau supÃ©rieur avec quelques informations globales
- Les `Ã©tapes` sont ici pour grouper les `commandes`. Ils ne dÃ©tiennent pas beaucoup de donnÃ©es, ils ont un index attributs qui est trÃ¨s important. L'ordre d'exÃ©cution dÃ©pend de cet index, l'utilisation d'une structure de donnÃ©es clÃ©/valeur au lieu d'un simple tableau permet d'insÃ©rer facilement des Ã©tapes entre les autres. Lorsqu'une action hÃ©rite d'une autre, elle peut insÃ©rer une Ã©tape en la dÃ©finissant avec un index qui se trouve entre deux autres Ã©tapes. C'est pourquoi nous augmentons habituellement les Ã©tapes de 10 ou 100 pour permettre des insertions potentielles plus tard
- La `commande` est liÃ©e Ã  un morceau de code Ã  exÃ©cuter, elle contient des `paramÃ¨tres` et est responsable d'appeler le code en fournissant la valeur de ses `paramÃ¨tres`. Il contient Ã©galement la sortie de l'exÃ©cution
- Le `paramÃ¨tre` peut soit stocker une valeur brute ou Ãªtre connectÃ© Ã  une sortie de `commande`. Il a un type et assure-vous que le type fourni est correct. Atention, pour les types invalides, silex va essayer de lancer la valeur, il est utile dans la plupart des cas, mais parfois il peut se traduire par des rÃ©sultats Ã©tranges.

:::tip
Vous devez Ãªtre prudant avec YAML, Une indentation peut rendre votre action entiÃ¨re fausse. Et l'erreur est trÃ¨s cryptique
:::

Voici Ã  quoi devrait ressembler une dÃ©finition d'action :

```yml
<action_name>:
  # Lâ€™Ã©tiquette est juste pour lâ€™affichage, vous pouvez lâ€™omettre, dans ce cas le nom sera utilisÃ© (la clÃ© qui est dans l'action)
  label: "<string> (default: value in the key)"
  # SpÃ©cifiez si cette action doit Ãªtre affichÃ©e sur lâ€™interface utilisateur, certaines actions nâ€™ont pas besoin dâ€™une interface avec une fenÃªtre contextuelle
  hide: "<boolean> (default: false)"
  # Un peu dâ€™aide qui sera affichÃ©e sur lâ€™interface utilisateur
  tooltip: "<string> || null (default: null)"

  steps:
    <step_name>:
      # Lâ€™Ã©tiquette est juste pour lâ€™affichage, vous pouvez lâ€™omettre, dans ce cas le nom sera utilisÃ© (la clÃ© qui est dans l'Ã©tape)
      label: "<string> (default: value in the key)"
      # PrÃ©ciser si cette Ã©tape doit Ãªtre affichÃ©e sur lâ€™interface utilisateur
      hide: "<boolean> (default: false)"
      # Un peu dâ€™aide qui sera affichÃ©e sur lâ€™interface utilisateur
      tooltip: "<string> || null (default: null)"
      # Lâ€™index est utilisÃ© pour dÃ©finir lâ€™ordre dâ€™exÃ©cution, on incrÃ©mente habituellement 10 par 10 pour pouvoir insÃ©rer des Ã©tapes plus tard si une autre action hÃ©rite de celle-ci
      index: "<int> (default: 0)"

      commands:
        <command_name>:
          # Le libellÃ© est juste pour lâ€™affichage, vous pouvez lâ€™omettre, dans ce cas le nom sera utilisÃ© (la clÃ© qui est dans cette commande)
          label: "<string> (default: value in the key)"
          # SpÃ©cifier si cette commande doit Ãªtre affichÃ©e sur lâ€™interface utilisateur
          hide: "<boolean> (default: false)"
          # Un peu dâ€™aide qui sera affichÃ©e sur lâ€™interface utilisateur
          tooltip: "<string> || null (default: null)"
          # Le chemin qui mÃ¨ne Ã  la commande python Ã  exÃ©cuter, le format est comme une important python rÃ©guliÃ¨re (ex: 'silex_plugin.commands.my_command.MyCommand'). Voir la page de dÃ©finition de commande pour plus d'informations)
          path: "<string> (default: '')"
          # PrÃ©ciser si lâ€™exÃ©cution doit sâ€™arrÃªter avant cette commande, et demander Ã  lâ€™utilisateur de modifier les paramÃ¨tres
          ask_user: "<boolean> (default: false)"

          parameters:
            <parameter_name>:
              # Lâ€™Ã©tiquette est juste pour lâ€™affichage, vous pouvez lâ€™omettre, dans ce cas le nom sera utilisÃ© (la clÃ© qui est dans ce paramÃ¨tre)
              label: "<string> (default: value in the key)"
              # PrÃ©ciser si ce paramÃ¨tre doit Ãªtre affichÃ© sur lâ€™interface utilisateur
              hide: "<boolean> (default: false)"
              # Un peu dâ€™aide qui sera affichÃ©e sur lâ€™interface utilisateur
              tooltip: "<string> || null (default: null)"
              # La valeur par dÃ©faut de ce paramÃ¨tre
              value: "<any> (default: null)"
```

## Connexions

Vous pouvez connecter la sortie d'une commande Ã  l'entrÃ©e d'un paramÃ¨tre. Pour ce faire, utilisez le tag `!command-output` avec un string spÃ©cifiant le chemin de la commande (ex: `value: !command-output "<step_name>:<command_name>"`)
Si la commande retourne un dictionnaire, vous pouvez obtenir une valeur spÃ©cifique de ce dictionnaire en ajoutant plus de clÃ©s au chemin.

Par exemple, si la commande retourne `{"foo": {"bar": "baz"}}` vous pouvez accÃ©der au string `baz` en dÃ©finissant le chemin sur `"<step_name>:<command_name>:foo:bar"`.

:::info
Nous utilisons les dictionnaires comme moyen pour les commandes d'avoir plusieurs sorties, c'est pourquoi il est toujours bon de sortir un dictionnaire dans les commandes mÃªme s'il n'y a qu'une sortie, juste au cas oÃ¹ nous le mettions Ã  jour plus tard avec plus de sorties.
:::

## HÃ©ritage

Certaines actions sont trÃ¨s similaire, pour Ã©viter d'avoir Ã  refaire les mÃªme choses encore et encore, vous pouvez utiliser l'hÃ©ritage. Pour utiliser l'hÃ©ritage, vous devez d'abord comprendre comment silex rÃ©sout une action Ã  partir de son nom. Il utilise la variable d'environment `SILEX_ACTION_CONFIG`, qui consiste en une liste de chemin, il suffit de lister la variable `PATH`.

Par exemple:

- <span>\\{PROD_ROOT}\rez\packages\test_pipe</span>
- <span>\\{PROD_ROOT}\rez\packages\silex_maya</span>
- <span>\\{PROD_ROOT}\rez\packages\silex_client</span>

Ici, le [contexte](./context.md) a silex_client chargÃ© et 2 plugins, silex_maya et test_pipe. L'ordre dans lequel les plugins sont chargÃ©s importe beaucoup. Lorsque silex cherche une action, il regarde de haut en bas de la liste. Vous devez le savoir si vous utilisez l'hÃ©ritage parce qu'une action ne peut **hÃ©riter que d'une autre action qui est dans le niveau actuel ou infÃ©rieur**.

La syntaxe pour l'hÃ©ritage est :

```yml
my_action: !inherit
  # Le nom de l'action dont vous voulez hÃ©riter. Vous pouvez ajouter un '.' devant le nom si vous voulez que silex commence Ã  chercher des actions au niveau actuel
  # Si vous ne mettez pas un . silex commencera Ã  chercher l'action en commenÃ§ant au niveau sous le niveau actuel.
  parent: "<string> (default: null)"
  # Si vous souhaitez hÃ©riter dâ€™une partie spÃ©cifique de lâ€™action, utilisez la clÃ© pour la spÃ©cifier
  key: "<string> (default: <same value as the parent>)"
  # Le nom de la catÃ©gorie de lâ€™action dont vous souhaitez hÃ©riter
  category: "<string> (default: <same value as the current category>)"
```

Vous n'avez pas Ã  hÃ©riter d'une action entiÃ¨re, une partie de votre action peut hÃ©riter d'une partie d'une autre action.
Dans l'exemple ci-dessous, le tag `!inherit` est utilisÃ©e Ã  la racine de l'action. Mais vous pouvez aussi l'utiliser Ã  la clÃ© d'une Ã©tape ou d'une commande.
Si vous le faites, vous devez utiliser l'option `key` et l'utiliser pour spÃ©cifier quelle partie de l'action vous voulez insÃ©rer (exemple: `action_name.step_name` si vous voulez une Ã©tape qui hÃ©rite d'une Ã©tape spÃ©cifique)

:::info
Le cas d'utilisation pour l'hÃ©ritage est gÃ©nÃ©ralement de rÃ©duire la rÃ©pÃ©tition [context](./context.md). For example,
you can create a plugin for a projects and customise the behaviour of that action for the contexts that includes this project specifically.
:::

To override a value, only add the keys for the value you want to override. For example, we have here a vrscene action (a vrscene publish)
which is customised for a certain project, we set the merge parameter to true (which is a hidden parameter) only for the contexts where that
plugin is loaded.

```yml
vrscene: !inherit
  parent: "vrscene"

  steps:
    move:
      commands:
        move:
          parameters:
            merge: true
```

## Value overrides order

From the point where the action is defined to the point where it is executed, some fields value can change in multiple ways. Here is the order in which a parameter value will me set:

1. The default value of the parameter is set in the command definition
2. It might then be overriden in the YAML definition of the action that uses that command
3. When the action is created the value can then be modified with `set_parameter` or the `--parameter` argument
4. When the action is executed, if the command is set to `ask_user: true`, the user will update the value before execution
5. Right after the user changes the value, the `setup` method is called which might set one last time the value. (see the command definition page)
